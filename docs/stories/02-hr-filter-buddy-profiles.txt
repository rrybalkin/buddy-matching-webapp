USER STORY: As HR, I want to filter buddy profiles by location, unit, and tech stack so I can find the best match.

IMPLEMENTATION OVERVIEW:
This user story is implemented through an advanced filtering system on the Buddies page that allows HR to search and filter buddy profiles using multiple criteria to find the most suitable matches for newcomers.

CORE IMPLEMENTATION COMPONENTS:

1. ADVANCED FILTERING INTERFACE
   Location: frontend/src/pages/BuddiesPage.tsx

   Filter Options Available:
   - Location: Search by city, office, or region
   - Unit/Department: Filter by engineering, product, design, etc.
   - Tech Stack: Filter by specific technologies (React, Node.js, Python, etc.)
   - Interests: Filter by personal interests (hiking, photography, etc.)
   - Availability: Show only available buddies
   - Experience Level: Filter by years of experience

2. BACKEND FILTERING API
   Location: backend/src/routes/buddies.ts (GET /api/buddies)

   Implementation Details:
   ```typescript
   // Query parameters supported
   const { location, unit, techStack, interests, available } = req.query;
   
   // Dynamic where clause construction
   const where: any = {
     isAvailable: available === 'true' ? true : undefined,
     user: { isActive: true }
   };

   // Location filtering (case-insensitive)
   if (location) {
     where.location = { contains: location as string, mode: 'insensitive' };
   }

   // Unit filtering (case-insensitive)
   if (unit) {
     where.unit = { contains: unit as string, mode: 'insensitive' };
   }

   // Tech stack filtering (array contains)
   if (techStack) {
     const techArray = (techStack as string).split(',').map(tech => tech.trim());
     where.techStack = { hasSome: techArray };
   }

   // Interests filtering (array contains)
   if (interests) {
     const interestArray = (interests as string).split(',').map(interest => interest.trim());
     where.interests = { hasSome: interestArray };
   }
   ```

3. FRONTEND FILTER INTERFACE
   Location: frontend/src/pages/BuddiesPage.tsx

   Filter Form Implementation:
   ```typescript
   const [filters, setFilters] = useState({
     location: '',
     unit: '',
     techStack: '',
     interests: '',
     available: ''
   });

   const handleFilterChange = (key: string, value: string) => {
     setFilters(prev => ({ ...prev, [key]: value }));
   };
   ```

   UI Components:
   - Text inputs for location and unit
   - Comma-separated input for tech stack
   - Comma-separated input for interests
   - Checkbox for availability filter
   - Real-time filtering as user types

4. DATABASE SCHEMA SUPPORT
   Location: backend/prisma/schema.prisma

   BuddyProfile Model:
   ```prisma
   model BuddyProfile {
     id        String  @id @default(cuid())
     userId    String  @unique
     user      User    @relation(fields: [userId], references: [id])
     
     location     String      // Filterable by location
     unit         String      // Filterable by unit/department
     techStack    String[]    // Array of technologies
     interests    String[]    // Array of personal interests
     maxBuddies   Int         // Capacity information
     isAvailable  Boolean     // Availability status
     
     experience   String?     // Experience level
     mentoringStyle String?   // Mentoring approach
     availability String?     // Time availability
   }
   ```

5. SEARCH FUNCTIONALITY

   Real-time Search:
   - Filters update results as user types
   - Debounced search to prevent excessive API calls
   - React Query for efficient data fetching and caching
   - Optimistic updates for better user experience

   Search Features:
   - Case-insensitive text search
   - Partial matching for location and unit
   - Array-based filtering for tech stack and interests
   - Multiple filter combinations supported

6. FILTER RESULTS DISPLAY

   Buddy Cards Layout:
   - Grid layout showing filtered results
   - Each card displays relevant information
   - Highlighted matching criteria
   - Clear indication of availability status
   - Current buddy load vs. maximum capacity

   Information Displayed:
   - Name and contact information
   - Location and unit
   - Tech stack (as tags)
   - Personal interests (as tags)
   - Current buddy count
   - Availability status
   - Experience level

7. FILTER PERSISTENCE

   URL State Management:
   - Filter parameters stored in URL
   - Bookmarkable filtered views
   - Browser back/forward support
   - Shareable filtered results

   Local Storage:
   - Remember last used filters
   - Quick access to common filter combinations
   - User preference persistence

COMPLETE USER JOURNEY:

1. HR navigates to Buddies page
2. HR sees filter form with multiple options
3. HR enters location (e.g., "San Francisco")
4. HR selects unit (e.g., "Engineering")
5. HR enters tech stack (e.g., "React, Node.js, TypeScript")
6. HR optionally adds interests (e.g., "Hiking, Photography")
7. HR checks availability filter
8. System filters and displays matching buddies
9. HR reviews filtered results
10. HR selects most suitable buddy for match

FILTER COMBINATIONS SUPPORTED:

✅ Single Filter: Location only, Unit only, Tech Stack only
✅ Multiple Filters: Any combination of filters
✅ Partial Matches: "San" matches "San Francisco"
✅ Array Filters: Multiple tech stacks or interests
✅ Availability: Show only available buddies
✅ Experience: Filter by experience level

TECHNICAL IMPLEMENTATION:

API Endpoints:
- GET /api/buddies?location=San Francisco&unit=Engineering&techStack=React,Node.js
- Query parameters: location, unit, techStack, interests, available

Database Queries:
- Prisma where clauses with contains and hasSome operators
- Case-insensitive text search
- Array-based filtering for tech stack and interests
- Efficient indexing on filterable fields

Frontend Components:
- FilterForm component with multiple input types
- BuddyCard component for displaying results
- useQuery hook for data fetching
- useState for filter state management

PERFORMANCE OPTIMIZATIONS:

✅ Debounced Search: Prevents excessive API calls
✅ Query Caching: React Query caches filter results
✅ Pagination: Large result sets are paginated
✅ Lazy Loading: Images and additional data loaded on demand
✅ Memoization: Expensive calculations are memoized

This implementation provides HR with powerful filtering capabilities to quickly find the most suitable buddy matches based on multiple criteria, ensuring optimal newcomer-buddy pairings.
